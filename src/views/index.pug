doctype html
html(lang='zh-Hans')
  head
    meta(charset='utf-8')
    meta(name='viewport' content='width=device-width')
    title= title
    link(rel='icon' type='image/x-icon' href='/favicon.ico')
    link(rel='icon' type='image/png' href='/hong.png')
    link(rel='stylesheet' href='vex.css')
    link(rel='stylesheet' href='vex-theme-os.css')
    style.
      @font-face {
        font-family: 'Song';
        src: url('/fonts/SourceHanSerifCN-Bold.woff2') format('woff2'),
             url('/fonts/SourceHanSerifCN-Bold.woff') format('woff'),
             url('/fonts/SourceHanSerifCN-Bold.ttf') format('truetype');
      }
      @font-face {
        font-family: 'Kai';
        src: url('/fonts/FZKTK.woff2') format('woff2'),
             url('/fonts/FZKTK.woff') format('woff'),
             url('/fonts/FZKTK.ttf') format('truetype');
      }
      svg text {
        font-family: "Noto Sans CJK SC", "Source Han Sans SC", "PingFang SC", "Hiragino Sans GB", "Heiti SC", "SimHei", "Microsoft YaHei";
        -webkit-font-smoothing: subpixel-antialiased;
        font-smoothing: subpixel-antialiased;
        text-anchor: middle;
        dominant-baseline: text-before-edge;
      }
      svg .title-text {
        font-family: Song, serif;
        font-size: 72pt;
      }
      svg .subtitle {
        font-size: 24pt;
      }
      svg .comment {
        font-size: 18pt;
        text-anchor: start;
      }
      svg .comment-border {
        fill: #DDD;
      }
      svg .node-name {
        font-family: Kai, sans-serif;
        font-size: 20pt;
      }
      svg .node-spouse {
        font-size: 10pt;
      }
      svg .node-note {
        font-size: 10pt;
      }
      svg .text-generation {
        font-size: 10pt;
      }
      svg .link {
        stroke: #000;
        stroke-width: 1;
      }
      svg .dash-link {
        stroke: #000;
        stroke-width: 1;
        stroke-dasharray: 5, 5;
      }
      svg .special-link {
        stroke: #000;
        stroke-width: 1;
        stroke-dasharray: 5, 2;
      }
      svg .line-generation {
        stroke: #000;
        stroke-width: 1;
        stroke-dasharray: 2, 8;
      }
      svg .node-border {
        stroke: #000;
        stroke-width: 2;
      }
      svg .detail-button {
        fill-opacity: 0.15;
      }
  body
    div#main
      svg#canvas

    script!= 'var familyData = ' + JSON.stringify(family) + ', titleData = "' + title + '", subtitleData = "' + subtitle + '", commentData = "' + comment + '", detailData = ' + JSON.stringify(detail) + ', changelog = "' + changelog + '";'
    script(src='/vex.combined.min.js')
    script vex.defaultOptions.className='vex-theme-os'
    script(src='/snap.svg-min.js')
    script(src='/is.min.js')
    script(src='/main.js')
    script.
      var treeInfo = nodesToTree(familyData, undefined, undefined, function(d) {
        if (d.Id >= 200) {
          if (d.Name && d.Name.length == 1) {
            return ' ' + d.Name + ' ';
          } else {
            return d.Name;
          }
        } else {
          return d.Name;
        }
      }, function(d) {
        ret = [];
        if (d.Alias) {
          ret.push('又名：' + d.Alias);
        }
        if (d.Spouse) {
          if (is.array(d.Spouse)) {
            var ret = [];
            ret.push('元：' + d.Spouse[0]); 
            ret.push('继：' + d.Spouse[1]);
          } else {
            var prefix = '偶：';
            if (d.Gender && d.Gender === 'M') prefix = '妻：';
            else if (d.Gender && d.Gender === 'F') prefix = '夫：';
            ret.push(prefix + d.Spouse);
          }
        }
        return ret;
      });
      var root = treeInfo.root;
      var id2Index = treeInfo.id2Index;
      var members = treeInfo.members;

      var layoutInfo = layoutTree(members, id2Index);
      var generationOffset = layoutInfo.generationOffset;
      var size = layoutInfo.size;

      var repeat = function(str, n) {
        var ret = "";
        for (var i = 0; i < n; i++)
          ret = ret + str;
        return ret;
      };
      var paper = Snap("#canvas");
      var titleBar = paper.g();
      var title = paper
        .text(size.width / 2, 0, titleData)
        .addClass('title-text')
        .attr('dx', '0' + repeat(' 24', titleData.length - 1))
        .transform('s1.4 1');
      if (is.ie() || is.edge()) {
        title.attr('y', title.getBBox().height * 0.8);
      }
      var titleHeight = title.getBBox().height;
      if (is.chrome() && is.windows())
        titleHeight -= 0.3 * title.getBBox().height;
      var subtitle = paper
        .text(size.width / 2, titleHeight + 40, subtitleData)
        .addClass('subtitle');
      if (is.ie() || is.edge()) {
        subtitle.attr('y', titleHeight + 40 + subtitle.getBBox().height * 0.8);
      }
      titleBar.add(title, subtitle);

      var content = paper.g().transform(Snap.format("t{x} {y}", {
        x: 0,
        y: titleBar.getBBox().height + 20
      }));

      for (var i = 0; i < members.length; i++) {
        drawNode(paper, content, members[i]);
        drawChildrenLink(paper, content, members[i], treeInfo, layoutInfo);
      }
      drawGeneration(paper, content, layoutInfo);
      setupDetailButton(paper, content, detailData, treeInfo);

      var commentText = paper
        .text(100, 20, commentData.split("\n"))
        .addClass('comment');
        commentText.selectAll('tspan:nth-child(n+2)')
        .attr({ dy: "1.2em" , x: 100 });
      var commentScale = Math.min(180.0 / commentText.getBBox().height, 850.0 / commentText.getBBox().width);
      commentText.transform(Snap.format('s{x} {y}', { x: commentScale, y: commentScale }));
      var commentBBox = commentText.getBBox();
      var commentRect = paper
        .rect(commentBBox.x - 20, commentBBox.y - 20, commentBBox.width + 40, commentBBox.height + 40)
        .addClass('comment-border');
      content.add(commentRect, commentText);

      var changelogText = paper
        .text(100, 2000, changelog.split("\n"))
        .addClass('comment');
        changelogText.selectAll('tspan:nth-child(n+2)')
        .attr({ dy: "1.2em" , x: 100 });
      var changelogBBox = changelogText.getBBox();
      var changelogRect = paper
        .rect(changelogBBox.x - 20, changelogBBox.y - 20, changelogBBox.width + 40, changelogBBox.height + 40)
        .addClass('comment-border');
      content.add(changelogRect, changelogText);

      paper.attr("width", size.width);
      paper.attr("height", titleBar.getBBox().height + content.getBBox().height + 40);

